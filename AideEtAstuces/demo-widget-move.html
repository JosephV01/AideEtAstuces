<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Démonstration - Déplacer le Widget sur le bureau - MyCustomDesk</title>
    <link rel="stylesheet" href="HelpAndTips.css">
    <link rel="stylesheet" href="demo-elements.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: var(--background-white);
            font-family: 'Segoe UI Variable', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .demo-container {
            background: var(--background-white);
            border: 2px solid var(--border-color);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px var(--shadow-light);
            text-align: center;
        }

        .demo-canvas-container {
            background: #2D2D2D;
            border: 2px solid #555555;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: inline-block;
        }

        /* Widget à déplacer */
        .movable-widget {
            position: absolute;
            border: 2px solid white;
            background: black;
            border-radius: 10px;
            width: 50px;
            height: 100px;
            left: 50px;
            top: 60px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
        }

        .widget-button {
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 100%;
            height: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
            border: none;
        }

        .widget-button:hover {
            background: rgba(0,255,255,0.2);
            color: cyan;
        }

        /* Éléments spécifiques à cette démo */
        .movable-widget {
            z-index: 1000;
        }

        /* back-button styles removed to use global styles in demo-elements.css */
    </style>
</head>
<body>
    <div class="demo-container">
        <div class="demo-header">
            <h1 class="demo-title">Démonstration - Déplacer le Widget sur le bureau</h1>
            <p class="demo-description">
                Cette démonstration montre comment déplacer le Widget sur votre bureau. Maintenez le clic gauche sur son étiquette tout en déplaçant la souris sur votre écran. Relâchez le clic une fois le widget correctement positionné.
        
            </p>
        </div>
        
        <!-- Contrôle de vitesse standardisé (avec barre de progression intégrée) -->
        <div class="speed-control">
            <label for="speedSlider">Vitesse de l'animation :</label>
            <input type="range" id="speedSlider" min="0.25" max="3" step="0.25" value="1" class="speed-slider">
            <span id="speedValue">1x</span>
            <button id="pauseButton" class="pause-button">Pause</button>
            <button class="back-button" onclick="window.close()">Fermer</button>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">Préparation de la démonstration...</div>
        </div>

        <div class="demo-canvas-container">
            <div class="demo-canvas">
                <!-- Widget à déplacer -->
                <div class="movable-widget">
                    <button class="widget-button">+</button>
                    <button class="widget-button">P</button>
                </div>
                
                <!-- Curseur de souris -->
                <div class="mouse-cursor"></div>

                <!-- Souris avec boutons (état normal) -->
                <div class="mouse-zero-click"></div>

                <!-- Souris avec bouton droit coloré (pour les clics) -->
                <div class="mouse-right-click"></div>

                <!-- Cercle d'animation de clic -->

                <!-- Position de destination (marqueur visuel) -->
                <div class="destination-marker"></div>
            </div>
        </div>

        
    </div>

    <script>
        // Variables pour l'animation
        let animationPhase = 0;
        let animationTimer;
        
        // Variables standardisées pour le contrôle de vitesse
        let animationSpeed = 1;
        let isPaused = false;
        let baseInterval = 30; // Intervalle de base pour cette démo (30ms)
        
        // Variables pour la progression
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        
        // Standardisation de la vitesse du curseur (selon demo-elements.css)
        const CURSOR_SPEED_PX_PER_FRAME = 9;

        // Éléments DOM
        const mouseCursor = document.querySelector('.mouse-cursor');
        const mouseZeroClick = document.querySelector('.mouse-zero-click');
        const mouseRightClick = document.querySelector('.mouse-right-click');
        const movableWidget = document.querySelector('.movable-widget');
        const widgetButtons = document.querySelectorAll('.widget-button');
        
        // Calculer les frames de déplacement selon la standardisation
        let movementFrames = 40; // Sera calculé dynamiquement
        let totalAnimationFrames = 0; // Sera calculé dynamiquement

        function startAnimation() {
            function runAnimationFrame() {
                // Vérifier si l'animation est en pause
                if (isPaused) {
                    animationTimer = setTimeout(runAnimationFrame, 100); // Vérifier toutes les 100ms
                    return;
                }
                
                animationPhase++;

                // 1 - Le curseur se dirige vers le widget, s'arrête en son centre
                if (animationPhase <= movementFrames) {
                    const progress = animationPhase / movementFrames;
                    const startX = 143, startY = 92;
                    const endX = 75, endY = 110; // Position finale correcte du curseur centré sur le widget
                    mouseCursor.style.left = (startX + (endX - startX) * progress) + 'px';
                    mouseCursor.style.top = (startY + (endY - startY) * progress) + 'px';
                }
                // 2 - Apparition de l'effet de clic
                else if (animationPhase <= movementFrames + 20) {
                    const clickPhase = animationPhase - movementFrames;
                    
                    // Changement de souris pour indiquer le clic
                    if (clickPhase >= 5) {
                        mouseZeroClick.style.visibility = 'hidden';
                        mouseRightClick.style.visibility = 'visible';
                        
                        // Widget devient surligné seulement quand on clique
                        widgetButtons.forEach(button => {
                            button.style.background = 'rgba(0,255,255,0.2)';
                            button.style.color = 'cyan';
                        });
                    }
                    
                    // Widget reste à sa position initiale
                    movableWidget.style.left = '50px';
                    movableWidget.style.top = '60px';
                    
                    // Curseur reste centré sur le widget
                    mouseCursor.style.left = '75px';
                    mouseCursor.style.top = '110px';
                }
                // 3 - Déplacement complet avec effets (clic maintenu)
                else if (animationPhase <= movementFrames + 60) {
                    const moveProgress = (animationPhase - (movementFrames + 20)) / 40;
                    const startX = 50, startY = 60;
                    const endX = 200, endY = 60;
                    movableWidget.style.left = (startX + (endX - startX) * moveProgress) + 'px';
                    movableWidget.style.top = (startY + (endY - startY) * moveProgress) + 'px';
                    
                    // Curseur suit le widget (position centrée sur le widget)
                    const widgetCenterX = startX + (endX - startX) * moveProgress + 25; // +25 pour centrer sur le widget
                    const widgetCenterY = startY + (endY - startY) * moveProgress + 50; // +50 pour centrer sur le widget
                    mouseCursor.style.left = (widgetCenterX - 8) + 'px'; // -8 pour centrer le curseur
                    mouseCursor.style.top = (widgetCenterY - 8) + 'px'; // -8 pour centrer le curseur
                    
                    // Effet de surbrillance maintenu pendant le déplacement (clic maintenu)
                    widgetButtons.forEach(button => {
                        button.style.background = 'rgba(0,255,255,0.2)';
                        button.style.color = 'cyan';
                    });
                }
                // 4 - Arrêt et disparition des effets
                else if (animationPhase <= movementFrames + 70) {
                    // Widget à destination, effets disparaissent
                    widgetButtons.forEach(button => {
                        button.style.background = 'transparent';
                        button.style.color = 'white';
                    });
                    
                    // Effet de clic disparaît aussi
                }
                // 5 - Relâchement du clic (retour à l'état normal de la souris)
                else if (animationPhase <= movementFrames + 80) {
                    // Retour à l'état normal de la souris (relâchement du clic)
                    mouseZeroClick.style.visibility = 'visible';
                    mouseRightClick.style.visibility = 'hidden';
                }
                // 6 - Widget à destination (sans clic, sans surbrillance)
                else if (animationPhase <= movementFrames + 100) {
                    // Widget reste à sa position de destination
                    movableWidget.style.left = '200px';
                    movableWidget.style.top = '60px';
                    
                    // Curseur reste centré sur le widget
                    mouseCursor.style.left = '225px';
                    mouseCursor.style.top = '110px';
                    
                    // Souris en état normal (pas de clic, pas de surbrillance)
                }
                // 7 - Nouveau clic pour le déplacement retour
                else if (animationPhase <= movementFrames + 105) {
                    const clickPhase = animationPhase - (movementFrames + 100);
                    
                    // Nouveau clic pour le déplacement retour
                    if (clickPhase >= 2) {
                        mouseZeroClick.style.visibility = 'hidden';
                        mouseRightClick.style.visibility = 'visible';
                        
                        // Widget devient surligné seulement quand on clique
                        widgetButtons.forEach(button => {
                            button.style.background = 'rgba(0,255,255,0.2)';
                            button.style.color = 'cyan';
                        });
                    }
                }
                // 8 - Déplacement retour complet avec effets (clic maintenu)
                else if (animationPhase <= movementFrames + 125) {
                    const moveProgress = (animationPhase - (movementFrames + 105)) / 20;
                    const startX = 200, startY = 60;
                    const endX = 50, endY = 60;
                    movableWidget.style.left = (startX + (endX - startX) * moveProgress) + 'px';
                    movableWidget.style.top = (startY + (endY - startY) * moveProgress) + 'px';
                    
                    // Curseur suit le widget (position centrée sur le widget)
                    const widgetCenterX = startX + (endX - startX) * moveProgress + 25; // +25 pour centrer sur le widget
                    const widgetCenterY = startY + (endY - startY) * moveProgress + 50; // +50 pour centrer sur le widget
                    mouseCursor.style.left = (widgetCenterX - 8) + 'px'; // -8 pour centrer le curseur
                    mouseCursor.style.top = (widgetCenterY - 8) + 'px'; // -8 pour centrer le curseur
                    
                    // Effet de surbrillance maintenu pendant le déplacement (clic maintenu)
                    widgetButtons.forEach(button => {
                        button.style.background = 'rgba(0,255,255,0.2)';
                        button.style.color = 'cyan';
                    });
                }
                // 9 - Arrêt et disparition des effets
                else if (animationPhase <= movementFrames + 135) {
                    // Widget à destination, effets disparaissent
                    widgetButtons.forEach(button => {
                        button.style.background = 'transparent';
                        button.style.color = 'white';
                    });
                    
                    // Effet de clic disparaît aussi
                }
                // 10 - Curseur disparaît
                else if (animationPhase <= movementFrames + 145) {
                    mouseCursor.style.opacity = '0';
                }
                // 11 - Delay
                else if (animationPhase <= movementFrames + 153) {
                    // Rien ne change, juste un délai
                }
                // Reset
                else {
                    animationPhase = 0;
                    movableWidget.style.left = '50px';
                    movableWidget.style.top = '60px';
                    mouseCursor.style.left = '143px';
                    mouseCursor.style.top = '92px';
                    mouseCursor.style.opacity = '1';
                    
                    // Reset de l'effet de clic
                    
                    // Reset des effets
                    widgetButtons.forEach(button => {
                        button.style.background = 'transparent';
                        button.style.color = 'white';
                    });
                    
                    // Reset de la souris
                    mouseZeroClick.style.visibility = 'visible';
                    mouseRightClick.style.visibility = 'hidden';
                }
                
                // Mettre à jour la progression
                updateProgress(animationPhase, totalAnimationFrames);
                
                // Calculer l'intervalle juste avant de programmer la prochaine frame
                const currentInterval = Math.round(baseInterval / animationSpeed);
                animationTimer = setTimeout(runAnimationFrame, currentInterval);
            }
            
            // Initialiser la progression
            updateProgress(0, totalAnimationFrames);
            
            // Démarrer la première frame
            runAnimationFrame();
        }

        // Fonction pour redémarrer l'animation avec la nouvelle vitesse
        function restartAnimationWithNewSpeed() {
            if (animationTimer) {
                clearTimeout(animationTimer);
            }
            startAnimation();
        }

        // Fonction pour changer la vitesse sans restart (réactivité maximale)
        function changeAnimationSpeed(newSpeed) {
            animationSpeed = newSpeed;
            // Pas besoin de restart, la prochaine frame utilisera automatiquement la nouvelle vitesse
        }
        
        // Fonction pour mettre à jour la progression
        function updateProgress(phase, totalFrames) {
            const percentage = phase >= totalFrames ? 100 : (phase / totalFrames) * 100;
            progressBar.style.width = percentage + '%';

            if (phase <= 0) { 
                progressText.textContent = 'Préparation de la démonstration...'; 
                return; 
            }

            const describe = (p) => {
                if (p <= movementFrames) return 'Déplacement vers le widget';
                if (p <= movementFrames + 20) return 'Clic sur le widget';
                if (p <= movementFrames + 60) return 'Déplacement du widget (1ère phase)';
                if (p <= movementFrames + 70) return 'Arrêt et relâchement du clic';
                if (p <= movementFrames + 80) return 'Relâchement du clic';
                if (p <= movementFrames + 100) return 'Widget à destination';
                if (p <= movementFrames + 105) return 'Nouveau clic pour le retour';
                if (p <= movementFrames + 125) return 'Déplacement retour du widget';
                if (p <= movementFrames + 135) return 'Arrêt final';
                if (p <= movementFrames + 145) return 'Fin de la démonstration';
                return 'Préparation du redémarrage...';
            };

            progressText.textContent = describe(phase);
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseButton = document.getElementById('pauseButton');
            
            if (isPaused) {
                pauseButton.textContent = 'Reprendre';
                pauseButton.classList.add('paused');
            } else {
                pauseButton.textContent = 'Pause';
                pauseButton.classList.remove('paused');
            }
        }

        // Démarrer l'animation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            // Calculer la durée de déplacement selon la standardisation
            const startX = 143, startY = 92;
            const endX = 75, endY = 110; // Position finale du curseur
            const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
            movementFrames = Math.ceil(distance / CURSOR_SPEED_PX_PER_FRAME);
            
            // Calculer le nombre total de frames de l'animation
            totalAnimationFrames = movementFrames + 20 + 40 + 10 + 10 + 20 + 5 + 20 + 10 + 10 + 8; // 153 frames total
            
            console.log(`Distance: ${Math.round(distance)}px, Frames: ${movementFrames}, Vitesse: ${CURSOR_SPEED_PX_PER_FRAME}px/frame, Total: ${totalAnimationFrames}`);
            
            // Initialiser le contrôle de vitesse
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            const pauseButton = document.getElementById('pauseButton');

            if (speedSlider && speedValue) {
                // Écouteur d'événement pour le slider
                speedSlider.addEventListener('input', function() {
                    const newSpeed = parseFloat(this.value);
                    speedValue.textContent = newSpeed + 'x';
                    
                    console.log('Nouvelle vitesse (widget-move):', newSpeed);
                    
                    // Changement de vitesse réactif sans restart
                    changeAnimationSpeed(newSpeed);
                });

                // Initialiser l'affichage de la vitesse
                speedValue.textContent = animationSpeed + 'x';
            } else {
                console.warn('Éléments du slider non trouvés dans demo-widget-move');
            }

            if (pauseButton) {
                pauseButton.addEventListener('click', togglePause);
            } else {
                console.warn('Bouton pause non trouvé dans demo-widget-move');
            }
            
            setTimeout(startAnimation, 1000);
        });
    </script>
</body>
</html>
