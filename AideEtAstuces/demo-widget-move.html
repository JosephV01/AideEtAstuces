<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Démonstration - Déplacer le Widget sur le bureau - MyCustomDesk</title>
    <link rel="stylesheet" href="HelpAndTips.css">
    <link rel="stylesheet" href="demo-elements.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: var(--background-white);
            font-family: 'Segoe UI Variable', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .demo-container {
            background: var(--background-white);
            border: 2px solid var(--border-color);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px var(--shadow-light);
            text-align: center;
        }

        .demo-canvas-container {
            background: #2D2D2D;
            border: 2px solid #555555;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: inline-block;
        }

        .demo-title {
            color: var(--text-color);
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .demo-description {
            color: var(--text-light);
            font-size: 1.1em;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        /* Widget à déplacer */
        .movable-widget {
            position: absolute;
            border: 2px solid white;
            background: black;
            border-radius: 10px;
            width: 50px;
            height: 100px;
            left: 50px;
            top: 60px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
        }

        .widget-button {
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 100%;
            height: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
            border: none;
        }

        .widget-button:hover {
            background: rgba(0,255,255,0.2);
            color: cyan;
        }

        /* Éléments spécifiques à cette démo */
        .movable-widget {
            z-index: 1000;
        }

        .back-button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1 class="demo-title">Démonstration - Déplacer le Widget sur le bureau</h1>
        <p class="demo-description">
            Cette démonstration montre comment déplacer le Widget sur votre bureau. Maintenez le clic gauche sur son étiquette tout en déplaçant la souris sur votre écran. Relâchez le clic une fois le widget correctement positionné.
        </p>
        
        <div class="demo-canvas-container">
            <div class="demo-canvas">
                <!-- Widget à déplacer -->
                <div class="movable-widget">
                    <button class="widget-button">+</button>
                    <button class="widget-button">P</button>
                </div>
                
                <!-- Curseur de souris -->
                <div class="mouse-cursor"></div>

                <!-- Souris avec boutons (état normal) -->
                <div class="mouse-zero-click"></div>

                <!-- Souris avec bouton droit coloré (pour les clics) -->
                <div class="mouse-right-click"></div>

                <!-- Cercle d'animation de clic -->

                <!-- Position de destination (marqueur visuel) -->
                <div class="destination-marker"></div>
            </div>
        </div>

        <!-- Contrôle de vitesse standardisé -->
        <div class="speed-control">
            <label for="speedSlider">Vitesse de l'animation :</label>
            <input type="range" id="speedSlider" min="0.25" max="3" step="0.25" value="1" class="speed-slider">
            <span id="speedValue">1x</span>
            <button id="pauseButton" class="pause-button">Pause</button>
        </div>

        <button class="back-button" onclick="window.close()">Fermer</button>
    </div>

    <script>
        // Variables pour l'animation
        let animationPhase = 0;
        let animationTimer;
        
        // Variables standardisées pour le contrôle de vitesse
        let animationSpeed = 1;
        let isPaused = false;
        let baseInterval = 30; // Intervalle de base pour cette démo (30ms)
        
        // Standardisation de la vitesse du curseur (selon demo-elements.css)
        const CURSOR_SPEED_PX_PER_FRAME = 9;

        // Éléments DOM
        const mouseCursor = document.querySelector('.mouse-cursor');
        const mouseZeroClick = document.querySelector('.mouse-zero-click');
        const mouseRightClick = document.querySelector('.mouse-right-click');
        const movableWidget = document.querySelector('.movable-widget');
        const widgetButtons = document.querySelectorAll('.widget-button');
        
        // Calculer les frames de déplacement selon la standardisation
        let movementFrames = 40; // Sera calculé dynamiquement

        function startAnimation() {
            function runAnimationFrame() {
                // Vérifier si l'animation est en pause
                if (isPaused) {
                    animationTimer = setTimeout(runAnimationFrame, 100); // Vérifier toutes les 100ms
                    return;
                }
                
                animationPhase++;

                // 1 - Le curseur se dirige vers le widget, s'arrête en son centre
                if (animationPhase <= movementFrames) {
                    const progress = animationPhase / movementFrames;
                    const startX = 143, startY = 92;
                    const endX = 75, endY = 110; // Position finale correcte du curseur centré sur le widget
                    mouseCursor.style.left = (startX + (endX - startX) * progress) + 'px';
                    mouseCursor.style.top = (startY + (endY - startY) * progress) + 'px';
                }
                // 2 - Apparition de l'effet de clic
                else if (animationPhase <= movementFrames + 20) {
                    const clickPhase = animationPhase - movementFrames;
                    
                    // L'effet de clic apparaît directement
                    
                    // Changement de souris pour indiquer le clic
                    if (clickPhase >= 5) {
                        mouseZeroClick.style.visibility = 'hidden';
                        mouseRightClick.style.visibility = 'visible';
                    }
                }
                // 3 - Widget devient hover (pas de déplacement)
                else if (animationPhase <= movementFrames + 40) {
                    const hoverPhase = animationPhase - (movementFrames + 20);
                    
                    // Widget devient hover
                    widgetButtons.forEach(button => {
                        button.style.background = 'rgba(0,255,255,0.2)';
                        button.style.color = 'cyan';
                    });
                    
                    // Widget reste à sa position initiale
                    movableWidget.style.left = '50px';
                    movableWidget.style.top = '60px';
                    
                    // Curseur reste centré sur le widget
                    mouseCursor.style.left = '75px';
                    mouseCursor.style.top = '110px';
                    
                    // Effet de clic persiste pendant le hover
                }
                // 4 - Déplacement complet avec effets
                else if (animationPhase <= movementFrames + 80) {
                    const moveProgress = (animationPhase - (movementFrames + 40)) / 40;
                    const startX = 50, startY = 60;
                    const endX = 200, endY = 60;
                    movableWidget.style.left = (startX + (endX - startX) * moveProgress) + 'px';
                    movableWidget.style.top = (startY + (endY - startY) * moveProgress) + 'px';
                    
                    // Curseur suit le widget (position centrée sur le widget)
                    const widgetCenterX = startX + (endX - startX) * moveProgress + 25; // +25 pour centrer sur le widget
                    const widgetCenterY = startY + (endY - startY) * moveProgress + 50; // +50 pour centrer sur le widget
                    mouseCursor.style.left = (widgetCenterX - 8) + 'px'; // -8 pour centrer le curseur
                    mouseCursor.style.top = (widgetCenterY - 8) + 'px'; // -8 pour centrer le curseur
                    
                    // Effet hover maintenu
                    widgetButtons.forEach(button => {
                        button.style.background = 'rgba(0,255,255,0.2)';
                        button.style.color = 'cyan';
                    });
                    
                    // Effet de clic persiste pendant le déplacement
                }
                // 5 - Arrêt et disparition des effets
                else if (animationPhase <= movementFrames + 90) {
                    // Widget à destination, effets disparaissent
                    widgetButtons.forEach(button => {
                        button.style.background = 'transparent';
                        button.style.color = 'white';
                    });
                    
                    // Effet de clic disparaît aussi
                }
                // 6 - Delay avec effet de clic persistant
                else if (animationPhase <= movementFrames + 100) {
                    // L'effet de clic reste visible pendant le délai
                }
                // 7 - Widget devient hover à destination
                else if (animationPhase <= movementFrames + 120) {
                    const hoverPhase = animationPhase - (movementFrames + 100);
                    
                    // Widget devient hover
                    widgetButtons.forEach(button => {
                        button.style.background = 'rgba(0,255,255,0.2)';
                        button.style.color = 'cyan';
                    });
                    
                    // Widget reste à sa position de destination
                    movableWidget.style.left = '200px';
                    movableWidget.style.top = '60px';
                    
                    // Curseur reste centré sur le widget
                    mouseCursor.style.left = '225px';
                    mouseCursor.style.top = '110px';
                    
                    // Effet de clic persiste pendant le hover
                }
                // 8 - Déplacement retour complet avec effets
                else if (animationPhase <= movementFrames + 140) {
                    const moveProgress = (animationPhase - (movementFrames + 120)) / 20;
                    const startX = 200, startY = 60;
                    const endX = 50, endY = 60;
                    movableWidget.style.left = (startX + (endX - startX) * moveProgress) + 'px';
                    movableWidget.style.top = (startY + (endY - startY) * moveProgress) + 'px';
                    
                    // Curseur suit le widget (position centrée sur le widget)
                    const widgetCenterX = startX + (endX - startX) * moveProgress + 25; // +25 pour centrer sur le widget
                    const widgetCenterY = startY + (endY - startY) * moveProgress + 50; // +50 pour centrer sur le widget
                    mouseCursor.style.left = (widgetCenterX - 8) + 'px'; // -8 pour centrer le curseur
                    mouseCursor.style.top = (widgetCenterY - 8) + 'px'; // -8 pour centrer le curseur
                    
                    // Effet hover maintenu
                    widgetButtons.forEach(button => {
                        button.style.background = 'rgba(0,255,255,0.2)';
                        button.style.color = 'cyan';
                    });
                    
                    // Effet de clic persiste pendant le déplacement retour
                }
                // 9 - Arrêt et disparition des effets
                else if (animationPhase <= movementFrames + 150) {
                    // Widget à destination, effets disparaissent
                    widgetButtons.forEach(button => {
                        button.style.background = 'transparent';
                        button.style.color = 'white';
                    });
                    
                    // Effet de clic disparaît aussi
                }
                // 10 - Curseur disparaît
                else if (animationPhase <= movementFrames + 160) {
                    mouseCursor.style.opacity = '0';
                }
                // 11 - Delay
                else if (animationPhase <= movementFrames + 168) {
                    // Rien ne change, juste un délai
                }
                // Reset
                else {
                    animationPhase = 0;
                    movableWidget.style.left = '50px';
                    movableWidget.style.top = '60px';
                    mouseCursor.style.left = '143px';
                    mouseCursor.style.top = '92px';
                    mouseCursor.style.opacity = '1';
                    
                    // Reset de l'effet de clic
                    
                    // Reset des effets
                    widgetButtons.forEach(button => {
                        button.style.background = 'transparent';
                        button.style.color = 'white';
                    });
                    
                    // Reset de la souris
                    mouseZeroClick.style.visibility = 'visible';
                    mouseRightClick.style.visibility = 'hidden';
                }
                
                // Calculer l'intervalle juste avant de programmer la prochaine frame
                const currentInterval = Math.round(baseInterval / animationSpeed);
                animationTimer = setTimeout(runAnimationFrame, currentInterval);
            }
            
            // Démarrer la première frame
            runAnimationFrame();
        }

        // Fonction pour redémarrer l'animation avec la nouvelle vitesse
        function restartAnimationWithNewSpeed() {
            if (animationTimer) {
                clearTimeout(animationTimer);
            }
            startAnimation();
        }

        // Fonction pour changer la vitesse sans restart (réactivité maximale)
        function changeAnimationSpeed(newSpeed) {
            animationSpeed = newSpeed;
            // Pas besoin de restart, la prochaine frame utilisera automatiquement la nouvelle vitesse
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseButton = document.getElementById('pauseButton');
            
            if (isPaused) {
                pauseButton.textContent = 'Reprendre';
                pauseButton.classList.add('paused');
            } else {
                pauseButton.textContent = 'Pause';
                pauseButton.classList.remove('paused');
            }
        }

        // Démarrer l'animation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            // Calculer la durée de déplacement selon la standardisation
            const startX = 143, startY = 92;
            const endX = 75, endY = 110; // Position finale du curseur
            const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
            movementFrames = Math.ceil(distance / CURSOR_SPEED_PX_PER_FRAME);
            
            console.log(`Distance: ${Math.round(distance)}px, Frames: ${movementFrames}, Vitesse: ${CURSOR_SPEED_PX_PER_FRAME}px/frame`);
            
            // Initialiser le contrôle de vitesse
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            const pauseButton = document.getElementById('pauseButton');

            if (speedSlider && speedValue) {
                // Écouteur d'événement pour le slider
                speedSlider.addEventListener('input', function() {
                    const newSpeed = parseFloat(this.value);
                    speedValue.textContent = newSpeed + 'x';
                    
                    console.log('Nouvelle vitesse (widget-move):', newSpeed);
                    
                    // Changement de vitesse réactif sans restart
                    changeAnimationSpeed(newSpeed);
                });

                // Initialiser l'affichage de la vitesse
                speedValue.textContent = animationSpeed + 'x';
            } else {
                console.warn('Éléments du slider non trouvés dans demo-widget-move');
            }

            if (pauseButton) {
                pauseButton.addEventListener('click', togglePause);
            } else {
                console.warn('Bouton pause non trouvé dans demo-widget-move');
            }
            
            setTimeout(startAnimation, 1000);
        });
    </script>
</body>
</html>
